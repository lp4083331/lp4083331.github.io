---
layout: post
title: "Go语言类型系统"
date: 2017-09-15
tag: Go语言 
---   

> 《Go语言实战》读书笔记之Go语言的类型系统

Go语言是一种静态类型的编程语言。编译器需要在编译时知晓值的类型，可以确保程序合理的使用值，有机会对代码进行优化。

值的类型提供两部分信息

1. 值的规模及需要分配多少内存给这个值
2. 这段内存表示什么



# 用户定义类型

## 结构类型

结构类型通过组合一系列固定且唯一的字段来声明，每个字段的类型既可以是内置类型，也可以是其他用户定义的类型。

***声明一个结构类型***

```
type user struct {
    name string
    email string
    ext int
    priveleged bool
}
```



***使用结构类型声明变量，并初始化为零值***

```
var bill user
```

结构里每个字段都会用**零值**初始化。



***使用结构字面量来声明结构类型的变量***

```
lisa := user{
    name:"Lisa"
    email:"lisa@email.com"
    ext:123
    privileged:true
}
```

这种形式对声明顺序没有要求



***不使用字段名，创建结构类型的值***

```
lisa := user{"lisa", "lisa@email.com",123,true}
```

这种形式值的顺序很重要，必须要和结构声明中字段顺序一致



## 已有类型

另一种声明用户定义类型的方法是基于一个已有的类型，使用这种声明类型的方法，从内置类型中创建出很多更加明确的类型，赋予更高级的功能。

***基于int64声明一个新类型***

`type Duration int64`

Go并不认为int64和Duration是同一种类型，两种不同类型的值即便互相兼容，也不能互相赋值，*编译器不会对不同类型的值做隐式转换*。



# 方法

方法能给用户定义的类型添加新的行为。方法实际上也是函数，只是在声明时，在关键字func和方法名之间增加了一个参数。关键字func和函数名之间的参数被成为接受者，将函数与接收者的类型绑在一起。

Go语言里有两种类型接受者

- 值接收者

  ```
  func (u user) notify(){
      fmt.Println("sending user email to %s<%s>\n",u.name, u.email)
  }
  ```

如果使用值接受者声明方法，调用时会使用这个值的一个副本来执行。使用bill的值作为接收者进行调用，方法notify会接收bill值的一个副本。

```
bill := user{"bill", "bill@email.com"}
bill.notify()
```

也可以使用指针来调用使用值接收者声明的方法

```
lisa := &user{"lisa", "lisa@email.com"}
lisa.notify()
```

可以认为Go语言执行了如下操作，notify操作的是一个副本，这里操作的是从lisa指针指向的值的副本

`(*lisa).notify()`

- 指针接收者

  ```
  func (u *user)changeEmail(email string){
      u.email = email
  }
  ```

当调用使用指针接收者声明的方法时，这个方法会共享调用方法时接收者所指向的值。

```
lisa.changeEmail("lisa@new.com")
bill.changeEmial("bill@new.com")
```

可以认为Go语言进行了如下操作

`(&bill).changeEmail("bill@new.com")`

转载请注明原地址，李鹏的博客：[http://lp4083331.github.io](http://lp4083331.github.io) 谢谢！